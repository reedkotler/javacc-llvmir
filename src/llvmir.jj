// // Based on grammar from https://github.com/llir/grammar

// ### [ Lexical part ] ########################################################

options {
  BUILD_PARSER=false;
 }
 PARSER_BEGIN(llvmir)
 public class llvmir {}
 PARSER_END(llvmir)
 TOKEN_MGR_DECLS: {
 }
 TOKEN: {
   <ascii_letter
	: ["A" - "Z"]
	| ["a" - "z"]
   >
 }
 TOKEN: {
   <letter
	: <ascii_letter>
	| "$"
	| "-"
	| "."
	| "_"
  >
  }
 TOKEN: {
   <escape_letter
    	: <letter>
   	    | "\\"
         >
  }

TOKEN: {
  <decimal_digit: ["0" - "9"]>
}

TOKEN: {<hex_digit
	: <decimal_digit>
	| ["A" - "F"]
	| ["a" - "f"] >
}


SKIP : {
   <COMMENT: ";" ( ~["\n"] )* "\n" >
}

SKIP : {
    <WHITESPACE :  "\\x00" | " " | "\t" | "\r" | "\n">
}

// === [ Identifiers ] =========================================================

TOKEN: {<name
	: <letter> ( <letter> | <decimal_digit> )*
	 >
	 }


TOKEN: {<escape_name
	: <escape_letter> ( <escape_letter> | <decimal_digit> )* >
}

TOKEN: {<quoted_name
	: <quoted_string>
>}


TOKEN: {<id
	: <decimals>
>}

// --- [ Global identifiers ] --------------------------------------------------

TOKEN: {<global_ident
	: <global_name>
	| <global_id>
>}

TOKEN: {<global_name
	: "@" ( <name> | <quoted_name> )
>}

TOKEN: {<global_id
	: "@" <id>
>}

// --- [ Local identifiers ] ---------------------------------------------------

TOKEN: {<local_ident
	: <local_name>
	| <local_id>
>}

TOKEN: {<local_name
	: "%" ( <name> | <quoted_name> )
>}

TOKEN: {<local_id
	: "%" <id> >}


// --- [ Labels ] --------------------------------------------------------------

//   Label             [-a-zA-Z$._0-9]+:

TOKEN: {<label_ident
	: ( <letter> | <decimal_digit> ) ( <letter> | <decimal_digit> )* ":"
	| <quoted_string> ":"
>}


// --- [ Attribute group identifiers ] -----------------------------------------

TOKEN: {<attr_group_id
	: "#" <id>
>}

// --- [ Comdat identifiers ] --------------------------------------------------

TOKEN: {<comdat_name
	: "$" ( <name> | <quoted_name> )
>}


// --- [ Metadata identifiers ] ------------------------------------------------

TOKEN: {<metadata_name
	: "!" <escape_name>
>}


TOKEN: {<metadata_id
	: "!" <id>
>}

// === [ Integer literals ] ====================================================

//   Integer           [-]?[0-9]+

TOKEN: {<int_lit
	: <decimal_lit>
>}

TOKEN: {<decimal_lit
	: ( "-" )? <decimals>
>}

TOKEN: {<decimals
	: <decimal_digit> (<decimal_digit>)*
>}

// === [ Floating-point literals ] =============================================

//   FPConstant        [-+]?[0-9]+[.][0-9]*([eE][-+]?[0-9]+)?

TOKEN: {<float_lit
	: <frac_lit>
	| <sci_lit>
	| <float_hex_lit>
>}

TOKEN: {<frac_lit
	: ( <sign>)? <decimals> "." ( <decimal_digit> )*
>}

TOKEN: {<sign
	: "+"
	| "-"
>}

TOKEN: {<sci_lit
	: <frac_lit> ( "e" | "E" ) ( <sign> )? <decimals>
>}

//   HexFPConstant     0x[0-9A-Fa-f]+     // 16 hex digits
//   HexFP80Constant   0xK[0-9A-Fa-f]+    // 20 hex digits
//   HexFP128Constant  0xL[0-9A-Fa-f]+    // 32 hex digits
//   HexPPC128Constant 0xM[0-9A-Fa-f]+    // 32 hex digits
//   HexHalfConstant   0xH[0-9A-Fa-f]+    // 4 hex digits

TOKEN: {<HexFPConstant :     "0" "x"     (<hex_digit>) * >}
TOKEN: {<HexFP80Constant :   "0" "x" "K" (<hex_digit>) * >}
TOKEN: {<HexFP128Constant :  "0" "x" "L" (<hex_digit>) * >}
TOKEN: {<HexPPC128Constant : "0" "x" "M" (<hex_digit>) * >}
TOKEN: {<HexHalfConstant :   "0" "x" "H" (<hex_digit>) * >}

TOKEN: {<float_hex_lit : <HexFPConstant> | <HexFP80Constant> |
  <HexFP128Constant> | <HexPPC128Constant> | <HexHalfConstant>
>}

// === [ String literals ] =====================================================

TOKEN: {<string_lit
	: <quoted_string> >}


TOKEN: {<quoted_string
	: "\"" ( ~["\""] )* "\""
>}

// === [ Types ] ===============================================================

TOKEN: {<int_type
	: "i" <decimals> >}

TOKEN:{<eq : "=">}

TOKEN:{<lbrace : "{">}

TOKEN:{<rbrace : "}">}

TOKEN:{<exclam : "!">}

TOKEN:{<comma : ",">}

// === [ Modules ] =============================================================

void Module() : {} {
	TopLevelDecls()
}

void TopLevelDecls(): {} {

	(TopLevelDecl())*
}

void TopLevelDecl(): {} {
	SourceFilename() |
	TargetSpec() |
	ModuleAsm () |
	TypeDef() |
	ComdatDef () |
	GlobalDecl () |
	GlobalDef () |
	FuncDecl () |
	FuncDef () |
	AttrGroupDef () |
	NamedMetadataDef () |
	MetadataDef ()
}


// --- [ Source filename ] -----------------------------------------------------

void SourceFilename(): {} {
	"source_filename" "=" <string_lit>
}

// --- [ Target specifiers ] ---------------------------------------------------

void TargetSpec() : {} {
	"target" DataLayout()
	"target" TargetTriple()
}


void DataLayout() : {} {
	"datalayout" "=" <string_lit>
}

void TargetTriple() : {} {
	"triple" "=" <string_lit>
}

// --- [ Module-level inline assembly ] ----------------------------------------

// ref: http://llvm.org/docs/LangRef.html#module-level-inline-assembly
void ModuleAsm() : {} {
	"module" "asm" <string_lit>
}

// --- [ Type definitions ] ----------------------------------------------------

void TypeDef() : {} {
	LocalIdent() "=" "type" Type()
	LocalIdent() "=" "type" "opaque"
}

// --- [ Comdat definitions ] --------------------------------------------------

void ComdatDef() : {} {
	ComdatName() "=" "comdat" SelectionKind()
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#comdats
void SelectionKind() : {} {
	"any"
	"exactmatch"
	"largest"
	"noduplicates"
	"samesize"
}

// --- [ Global variables ] ----------------------------------------------------

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    GlobalDecl
//       : GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType OptCommaSection OptCommaComdat OptCommaAlign OptCommaAttachedMDList   << astx.NewGlobalDecl($0, $3, $4, $5, $9) >>
//    ;
void GlobalDecl(): {} {
	  GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Align() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Comdat() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Comdat() "," Align() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() "," Align() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() "," Comdat() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() "," Comdat() "," Align() OptCommaAttachedMDList()
}

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    GlobalDef
//       : GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant OptCommaSection OptCommaComdat OptCommaAlign OptCommaAttachedMDList   << astx.NewGlobalDef($0, $3, $4, $5, $6, $10) >>
//    ;
void GlobalDef() : {}{
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Align() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Comdat() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Comdat() "," Align() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() "," Align() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() "," Comdat() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() "," Comdat() "," Align()
	                  OptCommaAttachedMDList()
}

void GlobalOptions() : {}{
	OptVisibility() OptDLLStorageClass() OptThreadLocal() OptUnnamedAddr() OptAddrSpace() OptExternallyInitialized()
}

void OptExternallyInitialized(): {} {
	(ExternallyInitialized())?
}

void ExternallyInitialized() : {}{
	"externally_initialized"
}

void Immutable() : {} {
	"constant"
	| "global"
}

// --- [ Functions ] -----------------------------------------------------------

void FuncDecl() : {} {
	"declare" AttachedMDs() OptExternLinkage() FuncHeader()
}

void FuncDef() : {}{
	"define" OptLinkage() FuncHeader() AttachedMDs() FuncBody()
}

void FuncHeader() : {}{
	OptVisibility() OptDLLStorageClass() OptCallConv() ParamAttrs() Type() GlobalIdent()
		"(" (Params())? ")" OptUnnamedAddr() FuncAttrs() OptSection() OptComdat() OptAlign()
		OptGC() OptPrefix() OptPrologue() OptPersonality()
}

void Params() : {}{
	"..."
	| ParamList()
	| ParamList() "," "..."
}

void ParamList() : {}{
	Param()
	| ParamList() "," Param()
}

void Param() : {}{
	FirstClassType() ParamAttrs()
	| FirstClassType() ParamAttrs() LocalIdent()
}

void FuncBody() : {} {
	"{" BasicBlockList() "}"
}

// --- [ Attribute group definitions ] -----------------------------------------

void AttrGroupDef() : {} {
	"attributes" AttrGroupID() "=" "{" FuncAttrList() "}"
}

// --- [ Metadata definitions ] ------------------------------------------------

void NamedMetadataDef() : {} {
	MetadataName() "=" "!" "{" MetadataIDs() "}"
}

void MetadataIDs() : {} {
	(MetadataIDList())?
}

void MetadataIDList() : {} {
	MetadataID()
	| MetadataIDList() "," MetadataID()
}

void MetadataDef() : {} {
	MetadataID() "=" ("distinct")? Metadata()
}

void Metadata() : {} {
	"!" "{" (MetadataNodesList())? "}"
}

void MetadataNodeList() : {} {
	MetadataNode()
	| MetadataNodeList() "," MetadataNode()
}

void MetadataNode() : {} {
	Metadata()
	| MetadataID()
	| "!" <string_lit>
	| Type() Constant()
}

// === [ Identifiers ] =========================================================

void GlobalIdent() : {} {
	<global_ident>
}

void LocalIdent() : {} {
	<local_ident>
}

void LabelIdent() : {} {
	<label_ident>
}

void AttrGroupID() : {} {
	<attr_group_id>
}

void ComdatName() : {} {
	<comdat_name>
}

void MetadataName() : {}{
	<metadata_name>
}

void MetadataID() : {} {
	<metadata_id>
}

// === [ Types ] ===============================================================

void Type() : {} {
	VoidType()
	| FuncType()
	| FirstClassType()
}

void FirstClassType() : {} {
	  IntType()
	| FloatType()
	| PointerType()
	| VectorType()
	| LabelType()
	| MetadataType()
	| ArrayType()
	| StructType()
	| NamedType()
}

// --- [ Void type ] -----------------------------------------------------------

void VoidType() : {} {
	"void"
}

// --- [ Function type ] -------------------------------------------------------

void FuncType() : {} {
	Type() "(" (ParamTypes())? ")"
}

void ParamTypes() : {} {
	 "..."
	| ParamTypeList()
	| ParamTypeList() "," "..."
}

void ParamTypeList() : {} {
	  ParamType()
	| ParamTypeList() "," ParamType()
}

void ParamType() : {} {
	 FirstClassType()
}

// --- [ Integer type ] --------------------------------------------------------

void IntType() : {} {
	<int_type>
}

// --- [ Floating-point type ] -------------------------------------------------

void FloatType() : {} {
	  "half"
	| "float"
	| "double"
	| "fp128"
	| "x86_fp80"
	| "ppc_fp128"
}

// --- [ Pointer type ] --------------------------------------------------------

void PointerType() : {} {
	Type() (AddrSpace())? "*"
}

void AddrSpace() : {} {
    "addrspace" "(" IntLit() ")"
}

// --- [ Vector type ] ---------------------------------------------------------

void VectorType(): {} {
	"<" IntLit() "x" FirstClassType() ">"
}

// --- [ Label type ] ----------------------------------------------------------

void LabelType() : {} {
	"label"
}

// --- [ Metadata type ] -------------------------------------------------------

void MetadataType() : {} {
	 "metadata"
}

// --- [ Array type ] ----------------------------------------------------------

void ArrayType() : {} {
	"[" IntLit() "x" FirstClassType() "]"
}

// --- [ struct type ] ---------------------------------------------------------

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    StructType
//       : "{" Fields "}"
//       | "<" "{" Fields "}" ">"
//    ;
//
//    Fields
//       : empty
//       | FieldList
//    ;
void StructType() : {} {
	  "{" "}"
	| "{" FieldList() "}"
	| "<" "{" "}" ">"
	| "<" "{" FieldList() "}" ">"
}

voie FieldList() : {} {
	  FirstClassType()
	| FieldList() "," FirstClassType()
}

// --- [ Named type ] ----------------------------------------------------------

void NamedType() : {} {
	LocalIdent()
}

// === [ Values ] ==============================================================

void Value() : {} {
	  LocalIdent()
	| Constant()
}

// === [ Constants ] ===========================================================

void Constant() : {} {
	  IntConst()
	| FloatConst()
	| NullConst()
	| VectorConst()
	| ArrayConst()
	| CharArrayConst()
	| StructConst()
	| ZeroInitializerConst()
	| GlobalIdent()
	| UndefConst()
	| ConstExpr()
}

// --- [ Integer constant ] ----------------------------------------------------

void IntConst() : {}{
	  IntLit()
	| BoolLit()
}

void IntLit() : {} {
	<int_lit>
}

void BoolLit() : {} {
	  "true"
	| "false"
}

// --- [ Floating-point constant ] ---------------------------------------------

void FloatConst() : {} {
	<float_lit>
}

// --- [ Pointer constant ] ----------------------------------------------------

void NullConst() : {} {
	"null"
}

// --- [ Vector constant ] -----------------------------------------------------

void VectorConst() : {}{
	"<" ElemList() ">"
}
// --- [ Array constant ] ------------------------------------------------------

void ArrayConst() : {} {
	"[" Elems() "]"
}

void CharArrayConst() : {} {
	"c" <string_lit>
}

// --- [ Struct constant ] -----------------------------------------------------

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    StructConst
//       : "{" Elems "}"
//       | "<" "{" Elems "}" ">"
//    ;
void StructConst() : {} {
	  "{" "}"
	| "{" ElemList() "}"
	| "<" "{" "}" ">"
	| "<" "{" ElemList() "}" ">"
}

// --- [ Zero initializer constant ] -------------------------------------------

void ZeroInitializerConst() : {} {
	"zeroinitializer"
}

// --- [ Undefined value constant ] --------------------------------------------

void UndefConst() : {} {
	"undef"
}

// === [ Constant expressions ] ================================================

void ConstExpr() : {} {
	// Binary expressions
	  AddExpr()
	| FAddExpr()
	| SubExpr()
	| FSubExpr()
	| MulExpr()
	| FMulExpr()
	| UDivExpr()
	| SDivExpr()
	| FDivExpr()
	| URemExpr()
	| SRemExpr()
	| FRemExpr()
	// Bitwise expressions
	| ShlExpr()
	| LShrExpr()
	| AShrExpr()
	| AndExpr()
	| OrExpr()
	| XorExpr()
	// Vector expressions
	| ExtractElementExpr()
	| InsertElementExpr()
	| ShuffleVectorExpr()
	// Aggregate expressions
	| ExtractValueExpr()
	| InsertValueExpr()
	// Memory expressions
	| GetElementPtrExpr()
	// Conversion expressions
	| TruncExpr()
	| ZExtExpr()
	| SExtExpr()
	| FPTruncExpr()
	| FPExtExpr()
	| FPToUIExpr()
	| FPToSIExpr()
	| UIToFPExpr()
	| SIToFPExpr()
	| PtrToIntExpr()
	| IntToPtrExpr()
	| BitCastExpr()
	| AddrSpaceCastExpr()
	// Other expressions
	| ICmpExpr()
	| FCmpExpr()
	| SelectExpr()
}

// --- [ Binary expressions ] --------------------------------------------------

void AddExpr() : {}{
	"add" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FAddExpr() : {} {
	"fadd" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void SubExpr() : {} {
	"sub" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FSubExpr() : {} {
	"fsub" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void MulExpr() : {} {
	"mul" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FMulExpr() : {} {
	"fmul" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void UDivExpr() : {} {
	"udiv" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void SDivExpr() : {}{
	"sdiv" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FDivExpr() : {} {
	"fdiv" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void URemExpr() : {} {
	"urem" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void SRemExpr() : {} {
	"srem" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FRemExpr() : {} {
	"frem" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

// --- [ Bitwise expressions ] -------------------------------------------------

void ShlExpr() : {}{
	"shl" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void LShrExpr() : {}{
	"lshr" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void AShrExpr() : {} {
	"ashr" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void AndExpr() : {} {
	"and" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void OrExpr() : {} {
	"or" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void XorExpr() : {} {
	"xor" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

// --- [ Vector expressions ] --------------------------------------------------

void ExtractElementExpr() : {} {
	"extractelement" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void InsertElementExpr() : {} {
	"insertelement" "(" FirstClassType() Constant() "," FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void ShuffleVectorExpr() : {} {
	"shufflevector" "(" FirstClassType() Constant() "," FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

// --- [ Aggregate expressions ] -----------------------------------------------

void ExtractValueExpr() : {} {
	"extractvalue" "(" FirstClassType() Constant() "," IntLitList() ")"
}

void InsertValueExpr() : {}{
	"insertvalue" "(" FirstClassType() Constant() "," FirstClassType() Constant() "," IntLitList() ")"
}

// --- [ Memory expressions ] --------------------------------------------------

void GetElementPtrExpr() : {} {
	"getelementptr" OptInbounds() "(" FirstClassType() "," FirstClassType() Constant() ConstIndices() ")"
}