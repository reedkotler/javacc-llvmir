// // Based on grammar from https://github.com/llir/grammar

// ### [ Lexical part ] ########################################################

options {
  BUILD_PARSER=false;
 }
 PARSER_BEGIN(llvmir)
 public class llvmir {}
 PARSER_END(llvmir)
 TOKEN_MGR_DECLS: {
 }
 TOKEN: {
   <ascii_letter
	: ["A" - "Z"]
	| ["a" - "z"]
   >
 }
 TOKEN: {
   <letter
	: <ascii_letter>
	| "$"
	| "-"
	| "."
	| "_"
  >
  }
 TOKEN: {
   <escape_letter
    	: <letter>
   	    | "\\"
         >
  }

TOKEN: {
  <decimal_digit: ["0" - "9"]>
}

TOKEN: {<hex_digit
	: <decimal_digit>
	| ["A" - "F"]
	| ["a" - "f"] >
}


SKIP : {
   <COMMENT: ";" ( ~["\n"] )* "\n" >
}

SKIP : {
    <WHITESPACE :  "\\x00" | " " | "\t" | "\r" | "\n">
}

// === [ Identifiers ] =========================================================

TOKEN: {<name
	: <letter> ( <letter> | <decimal_digit> )*
	 >
	 }


TOKEN: {<escape_name
	: <escape_letter> ( <escape_letter> | <decimal_digit> )* >
}

TOKEN: {<quoted_name
	: <quoted_string>
>}


TOKEN: {<id
	: <decimals>
>}

// --- [ Global identifiers ] --------------------------------------------------

TOKEN: {<global_ident
	: <global_name>
	| <global_id>
>}

TOKEN: {<global_name
	: "@" ( <name> | <quoted_name> )
>}

TOKEN: {<global_id
	: "@" <id>
>}

// --- [ Local identifiers ] ---------------------------------------------------

TOKEN: {<local_ident
	: <local_name>
	| <local_id>
>}

TOKEN: {<local_name
	: "%" ( <name> | <quoted_name> )
>}

TOKEN: {<local_id
	: "%" <id> >}


// --- [ Labels ] --------------------------------------------------------------

//   Label             [-a-zA-Z$._0-9]+:

TOKEN: {<label_ident
	: ( <letter> | <decimal_digit> ) ( <letter> | <decimal_digit> )* ":"
	| <quoted_string> ":"
>}


// --- [ Attribute group identifiers ] -----------------------------------------

TOKEN: {<attr_group_id
	: "#" <id>
>}

// --- [ Comdat identifiers ] --------------------------------------------------

TOKEN: {<comdat_name
	: "$" ( <name> | <quoted_name> )
>}


// --- [ Metadata identifiers ] ------------------------------------------------

TOKEN: {<metadata_name
	: "!" <escape_name>
>}


TOKEN: {<metadata_id
	: "!" <id>
>}

// === [ Integer literals ] ====================================================

//   Integer           [-]?[0-9]+

TOKEN: {<int_lit
	: <decimal_lit>
>}

TOKEN: {<decimal_lit
	: ( "-" )? <decimals>
>}

TOKEN: {<decimals
	: <decimal_digit> (<decimal_digit>)*
>}

// === [ Floating-point literals ] =============================================

//   FPConstant        [-+]?[0-9]+[.][0-9]*([eE][-+]?[0-9]+)?

TOKEN: {<float_lit
	: <frac_lit>
	| <sci_lit>
	| <float_hex_lit>
>}

TOKEN: {<frac_lit
	: ( <sign>)? <decimals> "." ( <decimal_digit> )*
>}

TOKEN: {<sign
	: "+"
	| "-"
>}

TOKEN: {<sci_lit
	: <frac_lit> ( "e" | "E" ) ( <sign> )? <decimals>
>}

//   HexFPConstant     0x[0-9A-Fa-f]+     // 16 hex digits
//   HexFP80Constant   0xK[0-9A-Fa-f]+    // 20 hex digits
//   HexFP128Constant  0xL[0-9A-Fa-f]+    // 32 hex digits
//   HexPPC128Constant 0xM[0-9A-Fa-f]+    // 32 hex digits
//   HexHalfConstant   0xH[0-9A-Fa-f]+    // 4 hex digits

TOKEN: {<HexFPConstant :     "0" "x"     (<hex_digit>) * >}
TOKEN: {<HexFP80Constant :   "0" "x" "K" (<hex_digit>) * >}
TOKEN: {<HexFP128Constant :  "0" "x" "L" (<hex_digit>) * >}
TOKEN: {<HexPPC128Constant : "0" "x" "M" (<hex_digit>) * >}
TOKEN: {<HexHalfConstant :   "0" "x" "H" (<hex_digit>) * >}

TOKEN: {<float_hex_lit : <HexFPConstant> | <HexFP80Constant> |
  <HexFP128Constant> | <HexPPC128Constant> | <HexHalfConstant>
>}

// === [ String literals ] =====================================================

TOKEN: {<string_lit
	: <quoted_string> >}


TOKEN: {<quoted_string
	: "\"" ( ~["\""] )* "\""
>}

// === [ Types ] ===============================================================

TOKEN: {<int_type
	: "i" <decimals> >}

//TOKEN:{<eq : "=">}

//TOKEN:{<lbrace : "{">}

//TOKEN:{<rbrace : "}">}

//TOKEN:{<exclam : "!">}

//TOKEN:{<comma : ",">}

// === [ Modules ] =============================================================

void Module() : {} {
	TopLevelDecls()
}

void TopLevelDecls(): {} {

	(TopLevelDecl())*
}

void TopLevelDecl(): {} {
	SourceFilename() |
	TargetSpec() |
	ModuleAsm () |
	TypeDef() |
	ComdatDef () |
	GlobalDecl () |
	GlobalDef () |
	FuncDecl () |
	FuncDef () |
	AttrGroupDef () |
	NamedMetadataDef () |
	MetadataDef ()
}


// --- [ Source filename ] -----------------------------------------------------

void SourceFilename(): {} {
	"source_filename" "=" <string_lit>
}

// --- [ Target specifiers ] ---------------------------------------------------

void TargetSpec() : {} {
	"target" DataLayout()
	"target" TargetTriple()
}


void DataLayout() : {} {
	"datalayout" "=" <string_lit>
}

void TargetTriple() : {} {
	"triple" "=" <string_lit>
}

// --- [ Module-level inline assembly ] ----------------------------------------

// ref: http://llvm.org/docs/LangRef.html#module-level-inline-assembly
void ModuleAsm() : {} {
	"module" "asm" <string_lit>
}

// --- [ Type definitions ] ----------------------------------------------------

void TypeDef() : {} {
	LocalIdent() "=" "type" Type()
	LocalIdent() "=" "type" "opaque"
}

// --- [ Comdat definitions ] --------------------------------------------------

void ComdatDef() : {} {
	ComdatName() "=" "comdat" SelectionKind()
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#comdats
void SelectionKind() : {} {
	"any"
	"exactmatch"
	"largest"
	"noduplicates"
	"samesize"
}

// --- [ Global variables ] ----------------------------------------------------

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    GlobalDecl
//       : GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType OptCommaSection OptCommaComdat OptCommaAlign OptCommaAttachedMDList   << astx.NewGlobalDecl($0, $3, $4, $5, $9) >>
//    ;
void GlobalDecl(): {} {
	  GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Align() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Comdat() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Comdat() "," Align() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() "," Align() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() "," Comdat() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() "," Comdat() "," Align() OptCommaAttachedMDList()
}

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    GlobalDef
//       : GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant OptCommaSection OptCommaComdat OptCommaAlign OptCommaAttachedMDList   << astx.NewGlobalDef($0, $3, $4, $5, $6, $10) >>
//    ;
void GlobalDef() : {}{
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Align() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Comdat() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Comdat() "," Align() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() "," Align() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() "," Comdat() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() "," Comdat() "," Align()
	                  OptCommaAttachedMDList()
}

void GlobalOptions() : {}{
	OptVisibility() OptDLLStorageClass() OptThreadLocal() OptUnnamedAddr() OptAddrSpace() OptExternallyInitialized()
}

void OptExternallyInitialized(): {} {
	(ExternallyInitialized())?
}

void ExternallyInitialized() : {}{
	"externally_initialized"
}

void Immutable() : {} {
	"constant"
	| "global"
}

// --- [ Functions ] -----------------------------------------------------------

void FuncDecl() : {} {
	"declare" AttachedMDs() OptExternLinkage() FuncHeader()
}

void FuncDef() : {}{
	"define" OptLinkage() FuncHeader() AttachedMDs() FuncBody()
}

void FuncHeader() : {}{
	OptVisibility() OptDLLStorageClass() OptCallConv() ParamAttrs() Type() GlobalIdent()
		"(" (Params())? ")" OptUnnamedAddr() FuncAttrs() OptSection() OptComdat() OptAlign()
		OptGC() OptPrefix() OptPrologue() OptPersonality()
}

void Params() : {}{
	"..."
	| ParamList()
	| ParamList() "," "..."
}

void ParamList() : {}{
	Param()
	| Param() "," ParamList()
}

void Param() : {}{
	FirstClassType() ParamAttrs()
	| FirstClassType() ParamAttrs() LocalIdent()
}

void FuncBody() : {} {
	"{" BasicBlockList() "}"
}

// --- [ Attribute group definitions ] -----------------------------------------

void AttrGroupDef() : {} {
	"attributes" AttrGroupID() "=" "{" FuncAttrList() "}"
}

// --- [ Metadata definitions ] ------------------------------------------------

void NamedMetadataDef() : {} {
	MetadataName() "=" "!" "{" MetadataIDs() "}"
}

void MetadataIDs() : {} {
	(MetadataIDList())?
}

void MetadataIDList() : {} {
	MetadataID()
	| MetadataID() "," MetadataIDList()
}

void MetadataDef() : {} {
	MetadataID() "=" ("distinct")? Metadata()
}

void Metadata() : {} {
	"!" "{" (MetadataNodeList())? "}"
}

void MetadataNodeList() : {} {
	MetadataNode()
	| MetadataNode() "," MetadataNodeList()
}

void MetadataNode() : {} {
	Metadata()
	| MetadataID()
	| "!" <string_lit>
	| Type() Constant()
}

// === [ Identifiers ] =========================================================

void GlobalIdent() : {} {
	<global_ident>
}

void LocalIdent() : {} {
	<local_ident>
}

void LabelIdent() : {} {
	<label_ident>
}

void AttrGroupID() : {} {
	<attr_group_id>
}

void ComdatName() : {} {
	<comdat_name>
}

void MetadataName() : {}{
	<metadata_name>
}

void MetadataID() : {} {
	<metadata_id>
}

// === [ Types ] ===============================================================

// need to sort out a left recursion problem here between pointer and
// function types and first class types

void Type() : {} {
	VoidType()
	| FuncType()
	| FirstClassType()
	| PointerType()
}

void FirstClassType() : {} {
	  IntType()
	| FloatType()
	| VectorType()
	| LabelType()
	| MetadataType()
	| ArrayType()
	| StructType()
	| NamedType()
}

// --- [ Void type ] -----------------------------------------------------------

void VoidType() : {} {
	"void"
}

// --- [ Function type ] -------------------------------------------------------

void FuncType() : {} {
	(VoidType() | FirstClassType() 	| PointerType() ) "(" (ParamTypes())? ")"
}

void ParamTypes() : {} {
	 "..."
	| ParamTypeList()
	| ParamTypeList() "," "..."
}

void ParamTypeList() : {} {
	  ParamType()
	| ParamType() "," ParamTypeList()
}

void ParamType() : {} {
	 FirstClassType()
}

// --- [ Integer type ] --------------------------------------------------------

void IntType() : {} {
	<int_type>
}

// --- [ Floating-point type ] -------------------------------------------------

void FloatType() : {} {
	  "half"
	| "float"
	| "double"
	| "fp128"
	| "x86_fp80"
	| "ppc_fp128"
}

// --- [ Pointer type ] --------------------------------------------------------

void PointerType() : {} {
	//Type() (AddrSpace())? "*"
	(VoidType() | FirstClassType() ) "*"

}

void OptAddrSpace() : {} {
	(AddrSpace())?
}

void AddrSpace() : {} {
    "addrspace" "(" IntLit() ")"
}

// --- [ Vector type ] ---------------------------------------------------------

void VectorType(): {} {
	"<" IntLit() "x" FirstClassType() ">"
}

// --- [ Label type ] ----------------------------------------------------------

void LabelType() : {} {
	"label"
}

// --- [ Metadata type ] -------------------------------------------------------

void MetadataType() : {} {
	 "metadata"
}

// --- [ Array type ] ----------------------------------------------------------

void ArrayType() : {} {
	"[" IntLit() "x" FirstClassType() "]"
}

// --- [ struct type ] ---------------------------------------------------------

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    StructType
//       : "{" Fields "}"
//       | "<" "{" Fields "}" ">"
//    ;
//
//    Fields
//       : empty
//       | FieldList
//    ;
void StructType() : {} {
	  "{" "}"
	| "{" FieldList() "}"
	| "<" "{" "}" ">"
	| "<" "{" FieldList() "}" ">"
}

voie FieldList() : {} {
	  FirstClassType()
	| FirstClassType() "," FieldList()
}

// --- [ Named type ] ----------------------------------------------------------

void NamedType() : {} {
	LocalIdent()
}

// === [ Values ] ==============================================================

void Value() : {} {
	  LocalIdent()
	| Constant()
}

// === [ Constants ] ===========================================================

void Constant() : {} {
	  IntConst()
	| FloatConst()
	| NullConst()
	| VectorConst()
	| ArrayConst()
	| CharArrayConst()
	| StructConst()
	| ZeroInitializerConst()
	| GlobalIdent()
	| UndefConst()
	| ConstExpr()
}

// --- [ Integer constant ] ----------------------------------------------------

void IntConst() : {}{
	  IntLit()
	| BoolLit()
}

void IntLit() : {} {
	<int_lit>
}

void BoolLit() : {} {
	  "true"
	| "false"
}

// --- [ Floating-point constant ] ---------------------------------------------

void FloatConst() : {} {
	<float_lit>
}

// --- [ Pointer constant ] ----------------------------------------------------

void NullConst() : {} {
	"null"
}

// --- [ Vector constant ] -----------------------------------------------------

void VectorConst() : {}{
	"<" ElemList() ">"
}
// --- [ Array constant ] ------------------------------------------------------

void ArrayConst() : {} {
	"[" Elems() "]"
}

void CharArrayConst() : {} {
	"c" <string_lit>
}

// --- [ Struct constant ] -----------------------------------------------------

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    StructConst
//       : "{" Elems "}"
//       | "<" "{" Elems "}" ">"
//    ;
void StructConst() : {} {
	  "{" "}"
	| "{" ElemList() "}"
	| "<" "{" "}" ">"
	| "<" "{" ElemList() "}" ">"
}

// --- [ Zero initializer constant ] -------------------------------------------

void ZeroInitializerConst() : {} {
	"zeroinitializer"
}

// --- [ Undefined value constant ] --------------------------------------------

void UndefConst() : {} {
	"undef"
}

// === [ Constant expressions ] ================================================

void ConstExpr() : {} {
	// Binary expressions
	  AddExpr()
	| FAddExpr()
	| SubExpr()
	| FSubExpr()
	| MulExpr()
	| FMulExpr()
	| UDivExpr()
	| SDivExpr()
	| FDivExpr()
	| URemExpr()
	| SRemExpr()
	| FRemExpr()
	// Bitwise expressions
	| ShlExpr()
	| LShrExpr()
	| AShrExpr()
	| AndExpr()
	| OrExpr()
	| XorExpr()
	// Vector expressions
	| ExtractElementExpr()
	| InsertElementExpr()
	| ShuffleVectorExpr()
	// Aggregate expressions
	| ExtractValueExpr()
	| InsertValueExpr()
	// Memory expressions
	| GetElementPtrExpr()
	// Conversion expressions
	| TruncExpr()
	| ZExtExpr()
	| SExtExpr()
	| FPTruncExpr()
	| FPExtExpr()
	| FPToUIExpr()
	| FPToSIExpr()
	| UIToFPExpr()
	| SIToFPExpr()
	| PtrToIntExpr()
	| IntToPtrExpr()
	| BitCastExpr()
	| AddrSpaceCastExpr()
	// Other expressions
	| ICmpExpr()
	| FCmpExpr()
	| SelectExpr()
}

// --- [ Binary expressions ] --------------------------------------------------

void AddExpr() : {}{
	"add" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FAddExpr() : {} {
	"fadd" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void SubExpr() : {} {
	"sub" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FSubExpr() : {} {
	"fsub" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void MulExpr() : {} {
	"mul" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FMulExpr() : {} {
	"fmul" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void UDivExpr() : {} {
	"udiv" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void SDivExpr() : {}{
	"sdiv" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FDivExpr() : {} {
	"fdiv" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void URemExpr() : {} {
	"urem" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void SRemExpr() : {} {
	"srem" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FRemExpr() : {} {
	"frem" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

// --- [ Bitwise expressions ] -------------------------------------------------

void ShlExpr() : {}{
	"shl" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void LShrExpr() : {}{
	"lshr" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void AShrExpr() : {} {
	"ashr" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void AndExpr() : {} {
	"and" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void OrExpr() : {} {
	"or" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void XorExpr() : {} {
	"xor" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

// --- [ Vector expressions ] --------------------------------------------------

void ExtractElementExpr() : {} {
	"extractelement" "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void InsertElementExpr() : {} {
	"insertelement" "(" FirstClassType() Constant() "," FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void ShuffleVectorExpr() : {} {
	"shufflevector" "(" FirstClassType() Constant() "," FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

// --- [ Aggregate expressions ] -----------------------------------------------

void ExtractValueExpr() : {} {
	"extractvalue" "(" FirstClassType() Constant() "," IntLitList() ")"
}

void InsertValueExpr() : {}{
	"insertvalue" "(" FirstClassType() Constant() "," FirstClassType() Constant() "," IntLitList() ")"
}

// --- [ Memory expressions ] --------------------------------------------------

void GetElementPtrExpr() : {} {
	"getelementptr" OptInbounds() "(" FirstClassType() "," FirstClassType() Constant() ConstIndices() ")"
}

void empty() : {} {
  {}
}

void ConstIndices(): {} {
	empty()
	| "," ConstIndexList()
}

void ConstIndexList() : {} {
	ConstIndex()
	| ConstIndex() "," ConstIndexList()
}

void ConstIndex() : {} {
	IntType() Constant()
}

// --- [ Conversion expressions ] ----------------------------------------------

void TruncExpr() : {} {
	"trunc" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void ZExtExpr() : {} {
	"zext" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void SExtExpr() : {} {
	"sext" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void FPTruncExpr() : {} {
    "fptrunc" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void FPExtExpr() : {} {
	"fpext" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void FPToUIExpr(): {} {
	"fptoui" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void FPToSIExpr(): {} {
	"fptosi" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void UIToFPExpr(): {} {
	"uitofp" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void SIToFPExpr() : {} {
	"sitofp" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void PtrToIntExpr() : {} {
	"ptrtoint" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void IntToPtrExpr() : {} {
	"inttoptr" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void BitCastExpr() : {} {
	"bitcast" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

void AddrSpaceCastExpr() : {} {
	"addrspacecast" "(" FirstClassType() Constant() "to" FirstClassType() ")"
}

// --- [ Other expressions ] ---------------------------------------------------

void ICmpExpr() : {}{
	"icmp" IntPred() "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void FCmpExpr() : {}{
	"fcmp" FloatPred() "(" FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

void SelectExpr() : {}{
	"select" "(" FirstClassType() Constant() "," FirstClassType() Constant() "," FirstClassType() Constant() ")"
}

// === [ Basic blocks ] ========================================================

void BasicBlockList() : {} {
	  BasicBlock()
	| BasicBlock() BasicBlockList()
}

void BasicBlock() : {} {
	OptLabelIdent() Instructions() Terminator()
}

void OptLabelIdent() : {} {
	   (LabelIdent())?
}

// === [ Instructions ] ========================================================

void Instructions(): {}{
	(InstructionList())?
}

void InstructionList() : {}{
	  Instruction()
	| Instruction() InstructionList()
}

void Instruction() : {} {
	  StoreInst()
	| FenceInst()
	| CmpXchgInst()
	| AtomicRMWInst()
	| LocalIdent() "=" ValueInstruction()
	| ValueInstruction()
}

void ValueInstruction() : {} {
	// Binary instructions
	  AddInst()
	| FAddInst()
	| SubInst()
	| FSubInst()
	| MulInst()
	| FMulInst()
	| UDivInst()
	| SDivInst()
	| FDivInst()
	| URemInst()
	| SRemInst()
	| FRemInst()
	// Bitwise instructions
	| ShlInst()
	| LShrInst()
	| AShrInst()
	| AndInst()
	| OrInst()
	| XorInst()
	// Vector instructions
	| ExtractElementInst()
	| InsertElementInst()
	| ShuffleVectorInst()
	// Aggregate instructions
	| ExtractValueInst()
	| InsertValueInst()
	// Memory instructions
	| AllocaInst()
	| LoadInst()
	| GetElementPtrInst()
	// Conversion instructions
	| TruncInst()
	| ZExtInst()
	| SExtInst()
	| FPTruncInst()
	| FPExtInst()
	| FPToUIInst()
	| FPToSIInst()
	| UIToFPInst()
	| SIToFPInst()
	| PtrToIntInst()
	| IntToPtrInst()
	| BitCastInst()
	| AddrSpaceCastInst()
	// Other instructions
	| ICmpInst()
	| FCmpInst()
	| PhiInst()
	| SelectInst()
	| CallInst()
	| VAArgInst()
	| LandingPadInst()
	| CatchPadInst()
	| CleanupPadInst()
}

// --- [ Binary instructions ] -------------------------------------------------

// ~~~ [ add ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void AddInst() : {} {
	"add" OverflowFlags() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ fadd ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FAddInst() : {} {
	"fadd" FastMathFlags() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ sub ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void SubInst() : {} {
	"sub" OverflowFlags() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ fsub ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FSubInst() : {} {
	"fsub" FastMathFlags() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ mul ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void MulInst() : {} {
	"mul" OverflowFlags() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ fmul ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FMulInst() : {} {
	"fmul" FastMathFlags() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ udiv ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void UDivInst() : {} {
	"udiv" OptExact() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ sdiv ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void SDivInst() : {} {
	"sdiv" OptExact() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ fdiv ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FDivInst() : {} {
	"fdiv" FastMathFlags() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ urem ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void URemInst() : {} {
	"urem" FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ srem ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void SRemInst() : {} {
	"srem" FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ frem ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FRemInst() : {} {
	"frem" FastMathFlags() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

void OverflowFlags() : {} {
	(OverflowFlagList())?
}

void OverflowFlagList() : {} {
	  OverflowFlag()
	| OverflowFlag() OverflowFlagList()
}

void OverflowFlag() : {} {
	  "nuw"
	| "nsw"
}

void FastMathFlags() : {} {
	(FastMathFlagList())?
}

void FastMathFlagList(): {} {
	  FastMathFlag()
	| FastMathFlag() FastMathFlagList()
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#fast-math-flags
void FastMathFlag() : {} {
	  "arcp"
	| "fast"
	| "ninf"
	| "nnan"
	| "nsz"
}

void OptExact() : {} {
	("exact")?
}

// --- [ Bitwise instructions ] ------------------------------------------------

// ~~~ [ shl ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void ShlInst() : {} {
	"shl" OverflowFlags() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ lshr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void LShrInst() : {} {
	"lshr" OptExact() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ ashr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void AShrInst() : {} {
	"ashr" OptExact() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ and ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void AndInst(): {} {
	"and" FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ or ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void OrInst(): {} {
	"or" FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// ~~~ [ xor ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void XorInst(): {} {
	"xor" FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

// --- [ Vector instructions ] -------------------------------------------------

// ~~~ [ extractelement ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void ExtractElementInst() : {} {
	"extractelement" FirstClassType() Value() "," FirstClassType() Value() OptCommaAttachedMDList()
}

// ~~~ [ insertelement ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void InsertElementInst() : {} {
	"insertelement" FirstClassType() Value() "," FirstClassType() Value() "," FirstClassType() Value() OptCommaAttachedMDList()
}

// ~~~ [ shufflevector ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void ShuffleVectorInst(): {} {
	"shufflevector" FirstClassType() Value() "," FirstClassType() Value() "," FirstClassType() Value() OptCommaAttachedMDList()
}

// --- [ Aggregate  instructions ] ---------------------------------------------

// ~~~ [ extractvalue ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void ExtractValueInst() : {} {
	"extractvalue" FirstClassType() Value() "," IntLitList() OptCommaAttachedMDList()
}

void IntLitList() : {} {
	  IntLit()
	| IntLit() "," IntLitList()
}

// ~~~ [ insertvalue ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void InsertValueInst(): {} {
	"insertvalue" FirstClassType() Value() "," FirstClassType() Value() "," IntLitList() OptCommaAttachedMDList()
}

// --- [ Memory instructions ] -------------------------------------------------

// ~~~ [ alloca ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    AllocaInst
//       : "alloca" FirstClassType OptCommaNElems OptCommaAlign OptCommaAttachedMDList   << astx.NewAllocaInst($1, $2, $4) >>
//    ;
//
//    OptCommaNElems
//       : empty
//       | "," NElems   << $1 >>
//    ;
void AllocaInst() : {} {
	  "alloca" FirstClassType() OptCommaAttachedMDList()
	| "alloca" FirstClassType() "," Align() OptCommaAttachedMDList()
	| "alloca" FirstClassType() "," NElems() OptCommaAttachedMDList()
	| "alloca" FirstClassType() "," NElems() "," Align() OptCommaAttachedMDList()
}

void NElems() : {} {
	FirstClassType() Value()
}

// ~~~ [ load ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    LoadInst
//       : "load" OptVolatile FirstClassType "," PointerType Value OptCommaAlign OptCommaAttachedMDList   << astx.NewLoadInst($2, $4, $5, $7) >>
//    ;
void LoadInst() : {} {
	  "load" OptVolatile() FirstClassType() "," PointerType() Value() OptCommaAttachedMDList()
	| "load" OptVolatile() FirstClassType() "," PointerType() Value() "," Align() OptCommaAttachedMDList()
}

void OptVolatile(): {} {
	("volatile")?
}

// ~~~ [ store ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    StoreInst
//       : "store" OptVolatile FirstClassType Value "," PointerType Value OptCommaAlign OptCommaAttachedMDList   << astx.NewStoreInst($2, $3, $5, $6, $8) >>
//    ;
void StoreInst() : {} {
	  "store" OptVolatile() FirstClassType() Value() "," PointerType() Value() OptCommaAttachedMDList()
	| "store" OptVolatile() FirstClassType() Value() "," PointerType() Value() "," Align() OptCommaAttachedMDList()
}

// ~~~ [ fence ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FenceInst() : {} {
	"fence" OptSinglethread() Ordering() OptCommaAttachedMDList()
}

void OptSinglethread(): {} {
	("singlethread")?
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#ordering
void Ordering() : {} {
	  "acq_rel"
	| "acquire"
	| "monotonic"
	| "release"
	| "seq_cst"
	| "unordered"
}

// ~~~ [ cmpxchg ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void CmpXchgInst() : {} {
	"cmpxchg" OptWeak() OptVolatile() FirstClassType() Value() "," FirstClassType() Value() "," FirstClassType()
	 Value() OptSinglethread() Ordering() Ordering() OptCommaAttachedMDList()
}

void OptWeak() : {} {
	("weak")?
}

// ~~~ [ atomicrmw ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void AtomicRMWInst(): {} {
	"atomicrmw" OptVolatile() AtomicOperation() FirstClassType() Value() ","
	FirstClassType() Value() OptSinglethread() Ordering() OptCommaAttachedMDList()
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#atomicrmw-instruction
void AtomicOperation(): {} {
	  "add"
	| "and"
	| "max"
	| "min"
	| "nand"
	| "or"
	| "sub"
	| "umax"
	| "umin"
	| "xchg"
	| "xor"
}

// ~~~ [ getelementptr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//    GetElementPtrInst
//       : "getelementptr" OptInbounds FirstClassType "," FirstClassType Value Indices OptCommaAttachedMDList   << astx.NewGetElementPtrInst($2, $4, $5, $6, $7) >>
//    ;
//
//    Indices
//       : empty
//       | "," IndexList   << $1, nil >>
//    ;
void GetElementPtrInst(): {} {
	  "getelementptr" OptInbounds() FirstClassType() "," FirstClassType() Value() OptCommaAttachedMDList()
	  "getelementptr" OptInbounds() FirstClassType() "," FirstClassType()
	      Value() "," IndexList() OptCommaAttachedMDList()
}

void IndexList() : {} {
	  Index()
	| Index() "," IndexList()
}

void Index() : {} {
	IntType() Value()
}

// --- [ Conversion instructions ] ---------------------------------------------

// ~~~ [ trunc ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void TruncInst() : {} {
	"trunc" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}
// ~~~ [ zext ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void ZExtInst(): {} {
	"zext" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}
// ~~~ [ sext ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void SExtInst() : {} {
	"sext" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}

// ~~~ [ fptrunc ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FPTruncInst() : {} {
	"fptrunc" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}

// ~~~ [ fpext ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FPExtInst(): {} {
	"fpext" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}

// ~~~ [ fptoui ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FPToUIInst() : {} {
	"fptoui" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}

// ~~~ [ fptosi ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FPToSIInst() : {} {
	"fptosi" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}

// ~~~ [ uitofp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void UIToFPInst(): {} {
	"uitofp" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}

// ~~~ [ sitofp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void SIToFPInst() : {} {
	"sitofp" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}

// ~~~ [ ptrtoint ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void PtrToIntInst(): {} {
	"ptrtoint" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}

// ~~~ [ inttoptr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void IntToPtrInst(): {} {
	"inttoptr" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}
// ~~~ [ bitcast ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void BitCastInst() : {} {
	"bitcast" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}
// ~~~ [ addrspacecast ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void AddrSpaceCastInst(): {} {
	"addrspacecast" FirstClassType() Value() "to" FirstClassType() OptCommaAttachedMDList()
}

// --- [ Other instructions ] --------------------------------------------------

// ~~~ [ icmp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void ICmpInst() : {} {
	"icmp" IntPred() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

void IntPred() : {} {
	  "eq"
	| "ne"
	| "ugt"
	| "uge"
	| "ult"
	| "ule"
	| "sgt"
	| "sge"
	| "slt"
	| "sle"
}

// ~~~ [ fcmp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void FCmpInst() : {} {
	"fcmp" FastMathFlags() FloatPred() FirstClassType() Value() "," Value() OptCommaAttachedMDList()
}

void FloatPred() : {} {
	  "false"
	| "oeq"
	| "ogt"
	| "oge"
	| "olt"
	| "ole"
	| "one"
	| "ord"
	| "ueq"
	| "ugt"
	| "uge"
	| "ult"
	| "ule"
	| "une"
	| "uno"
	| "true"
}

// ~~~ [ phi ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void PhiInst() : {} {
	"phi" FirstClassType() IncomingList() OptCommaAttachedMDList()
}

void IncomingList() : {} {
	  Incoming()
	| Incoming() "," IncomingList()
}

void Incoming(): {} {
	"[" Value() "," LocalIdent() "]"
}

// ~~~ [ select ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void SelectInst() : {} {
	"select" FirstClassType() Value() "," FirstClassType() Value() ","
	 FirstClassType() Value() OptCommaAttachedMDList()
}

// ~~~ [ call ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void CallInst() : {} {
	OptTail() "call" FastMathFlags() OptCallConv() ParamAttrs() Type() Value()
	 "(" Args() ")" FuncAttrs() OptCommaAttachedMDList()
}

void OptTail() : {} {
	(Tail())?
}

void Tail() : {} {
	  "tail"
	| "musttail"
	| "notail"
}

void Args(): {} {
    (ArgList())?
}

void ArgList(): {} {
	  Arg()
	| Arg() "," ArgList()
}

void Arg() : {} {
	FirstClassType() ParamAttrs() Value()
}

// ~~~ [ va_arg ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void VAArgInst(): {} {
	"va_arg" FirstClassType() Value() "," FirstClassType()
	 OptCommaAttachedMDList()
}



// ~~~ [ landingpad ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void LandingPadInst() : {} {
	  "landingpad" FirstClassType() ClauseList() OptCommaAttachedMDList()
	| "landingpad" FirstClassType() "cleanup" Clauses() OptCommaAttachedMDList()
}

void Clauses() : {} {
	(ClauseList())?
}

void ClauseList(): {} {
	  Clause()
	| Clause() ClauseList()
}

void Clause() : {} {
	   "catch" FirstClassType() Value()
	| "filter" FirstClassType() ArrayConst()
}

// ~~~ [ catchpad ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void CatchPadInst(): {} {
	"catchpad" "within" LocalIdent() ArrayConst() OptCommaAttachedMDList()
}

// ~~~ [ cleanuppad ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void CleanupPadInst(): {} {
	"cleanuppad" "within" ExceptionParent() ArrayConst() OptCommaAttachedMDList()
}

void ExceptionParent(): {} {
	  "none"
	| LocalIdent()
}

// === [ Terminators ] =========================================================

void Terminator() : {} {
	  RetTerm()
	| BrTerm()
	| CondBrTerm()
	| SwitchTerm()
	| IndirectBrTerm()
	| InvokeTerm()
	| ResumeTerm()
	| CatchSwitchTerm()
	| CatchRetTerm()
	| CleanupRetTerm()
	| UnreachableTerm()
}

// ~~~ [ ret ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void RetTerm(): {} {
	  "ret" VoidType() OptCommaAttachedMDList()
	| "ret" FirstClassType() Value() OptCommaAttachedMDList()
}

// ~~~ [ br ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Unconditional branch terminator.
void BrTerm(): {} {
	"br" LabelType() LocalIdent() OptCommaAttachedMDList()
}

// Conditional branch terminator.
void CondBrTerm(): {} {
	"br" IntType() Value() "," LabelType() LocalIdent() "," LabelType()
	     LocalIdent() OptCommaAttachedMDList()
}

// ~~~ [ switch ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void SwitchTerm(): {} {
	"switch" IntType() Value() "," LabelType() LocalIdent()
	   "[" Cases() "]" OptCommaAttachedMDList()
}

void Cases(): {} {
	(CaseList())?
}

void CaseList() : {} {
	  Case()
	| Case() CaseList()
}

void Case(): {} {
	IntType() Value() "," LabelType() LocalIdent()
}

// ~~~ [ indirectbr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void IndirectBrTerm(): {} {
	"indirectbr" FirstClassType() Value() "," "[" Labels() "]"
	OptCommaAttachedMDList()
}
// ~~~ [ invoke ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void InvokeTerm() : {} {
	"invoke" OptCallConv() ParamAttrs() Type() Value()
	   "(" Args() ")" FuncAttrs() OptOperandBundle() "to"
	    LabelType() LocalIdent() "unwind" LabelType() LocalIdent()
	    OptCommaAttachedMDList()
}

void OptOperandBundle() : {} {
	(OperandBundle())?
}

void OperandBundle(): {} {
	"[" TagValues() "]"
}

void TagValues(): {} {
	(TagValueList())?
}

void TagValueList(): {} {
	  TagValue()
	| TagValue() "," TagValueList()
}

void TagValue(): {} {
	<string_lit> "(" Values() ")"
}

void Values(): {} {
	(ValueList())?
}

void ValueList() : {} {
	FirstClassType() Value()
	| FirstClassType() Value() "," ValueList()
}

// ~~~ [ resume ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void ResumeTerm() : {} {
	"resume" FirstClassType() Value() OptCommaAttachedMDList()
}

// ~~~ [ catchswitch ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void CatchSwitchTerm(): {} {
	  "catchswitch" "within" ExceptionParent() "[" Labels() "]" "unwind"
	      "to" "caller" OptCommaAttachedMDList()
	| "catchswitch" "within" ExceptionParent() "[" Labels() "]" "unwind"
	       LabelType() LocalIdent() OptCommaAttachedMDList()
}

// ~~~ [ catchret ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void CatchRetTerm(): {} {
	"catchret" "from" Value() "to" LabelType() LocalIdent()
	    OptCommaAttachedMDList()
}

// ~~~ [ cleanupret ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void CleanupRetTerm(): {}{
	  "cleanupret" "from" Value() "unwind" "to" "caller"
	       OptCommaAttachedMDList()
	| "cleanupret" "from" Value() "unwind" LabelType() LocalIdent()
	   OptCommaAttachedMDList()
}

// ~~~ [ unreachable ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void UnreachableTerm(): {} {
	"unreachable" OptCommaAttachedMDList()
}

// ### [ Helper productions ] ##################################################

void OptLinkage() : {} {
	(Linkage())?
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#linkage
void Linkage() : {} {
	  "appending"
	| "available_externally"
	| "common"
	| "internal"
	| "linkonce"
	| "linkonce_odr"
	| "private"
	| "weak"
	| "weak_odr"
}

void OptExternLinkage(): {} {
	(ExternLinkage())?
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#linkage
void ExternLinkage(): {} {
	  "extern_weak"
	| "external"
}

void OptVisibility(): {} {
	(Visibility())?
}

// From spec of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#visibility-styles
void Visibility(): {} {
	  "default"
	| "hidden"
	| "protected"
}

void OptDLLStorageClass(): {} {
	(DLLStorageClass())?
}

// From spec of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#dllstorageclass
void DLLStorageClass(): {} {
	  "dllimport"
	| "dllexport"
}

void OptThreadLocal(): {} {
	(ThreadLocal())?
}

// From spec of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#thread-local-storage-models
void ThreadLocal(): {} {
	  "thread_local"
	| "thread_local" "(" TLSModel() ")"
}

void TLSModel(): {} {
	  "localdynamic"
	| "initialexec"
	| "localexec"
}

void OptUnnamedAddr(): {} {
	(UnnamedAddr())?
}

void UnnamedAddr(): {} {
	  "local_unnamed_addr"
	| "unnamed_addr"
}

void OptSection(): {} {
	(Section())?
}

void Section(): {} {
	"section" <string_lit>
}

void OptComdat(): {} {
	(Comdat())?
}

void Comdat(): {} {
	  "comdat"
	| "comdat" "(" ComdatName() ")"
}

void OptAlign(): {} {
	(Align())?
}

void Align(): {} {
	"align" IntLit()
}

void OptGC(): {} {
	(GC())?
}

void GC(): {} {
	"gc" <string_lit>
}

void OptPrefix(): {} {
	(Prefix())?
}

// ref: http://llvm.org/docs/LangRef.html#prefix-data
void Prefix(): {} {
	"prefix" FirstClassType() Constant()
}

void OptPrologue(): {} {
	(Prologue())?
}

// ref: http://llvm.org/docs/LangRef.html#prologue-data
void Prologue(): {} {
	"prologue" FirstClassType() Constant()
}

void OptPersonality(): {} {
	(Personality())?
}

// ref: http://llvm.org/docs/LangRef.html#personality-function
void Personality(): {} {
	"personality" FirstClassType() Constant()
}

void ParamAttrs(): {} {
	(ParamAttrList())?
}

void ParamAttrList(): {} {
	  ParamAttr()
	| ParamAttr() ParamAttrList()
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#parameter-attributes
void ParamAttr() : {} {
	  <string_lit>
	| <string_lit> "=" <string_lit>
	| Align()
	| "byval"
	| "dereferenceable" "(" IntLit() ")"
	| "dereferenceable_or_null" "(" IntLit() ")"
	| "inalloca"
	| "inreg"
	| "nest"
	| "noalias"
	| "nocapture"
	| "nonnull"
	| "readnone" // NOTE: accepted by lli but not part of spec in v4.0
	| "readonly" // NOTE: accepted by lli but not part of spec in v4.0
	| "returned"
	| "signext"
	| "sret"
	| "swifterror"
	| "swiftself"
	| "writeonly" // NOTE: accepted by lli but not part of spec in v4.0
	| "zeroext"
}

void FuncAttrs(): {} {
	(FuncAttrList())?
}

void FuncAttrList(): {} {
	  FuncAttr()
	| FuncAttr() FuncAttrList()
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#function-attributes
void FuncAttr(): {} {
	  <string_lit>
	| <string_lit> "=" <string_lit>
	| AttrGroupID()
	| "alignstack" "=" IntLit() // NOTE: only valid in attribute group definitions.
	| "alignstack" "(" IntLit() ")"
	| "allocsize" "(" IntLit() ")"
	| "allocsize" "(" IntLit() "," IntLit() ")"
	| "alwaysinline"
	| "argmemonly"
	| "builtin"
	| "cold"
	| "convergent"
	| "inaccessiblemem_or_argmemonly"
	| "inaccessiblememonly"
	| "inlinehint"
	| "jumptable"
	| "minsize"
	| "naked"
	| "nobuiltin"
	| "noduplicate"
	| "noimplicitfloat"
	| "noinline"
	| "nonlazybind"
	| "norecurse"
	| "noredzone"
	| "noreturn"
	| "nounwind"
	| "optnone"
	| "optsize"
	| "readnone"
	| "readonly"
	| "returns_twice"
	| "safestack"
	| "sanitize_address"
	| "sanitize_memory"
	| "sanitize_thread"
	| "ssp"
	| "sspreq"
	| "sspstrong"
	| "uwtable"
	| "writeonly"
}

void Elems() : {} {
	(ElemList())?
}

void ElemList(): {} {
	  Elem()
	| Elem() "," ElemList()
}

void Elem(): {} {
	FirstClassType() Value()
}

void OptCallConv(): {} {
	(CallConv())?
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#callingconv
void CallConv(): {} {
	  "amdgpu_cs"
	| "amdgpu_gs"
	| "amdgpu_kernel"
	| "amdgpu_ps"
	| "amdgpu_vs"
	| "anyregcc"
	| "arm_aapcs_vfpcc"
	| "arm_aapcscc"
	| "arm_apcscc"
	| "avr_intrcc"
	| "avr_signalcc"
	| "cc" IntLit()
	| "ccc"
	| "coldcc"
	| "cxx_fast_tlscc"
	| "fastcc"
	| "ghccc"
	| "hhvm_ccc"
	| "hhvmcc"
	| "intel_ocl_bicc"
	| "msp430_intrcc"
	| "preserve_allcc"
	| "preserve_mostcc"
	| "ptx_device"
	| "ptx_kernel"
	| "spir_func"
	| "spir_kernel"
	| "swiftcc"
	| "webkit_jscc"
	| "x86_64_sysvcc"
	| "x86_64_win64cc"
	| "x86_fastcallcc"
	| "x86_intrcc"
	| "x86_regcallcc"
	| "x86_stdcallcc"
	| "x86_thiscallcc"
	| "x86_vectorcallcc"
}


void Labels(): {} {
	(LabelList())?
}

void LabelList(): {} {
	  Label()
	| Label() "," LabelList()
}

void Label(): {} {
	LabelType() LocalIdent()
}

void OptInbounds(): {} {
	("inbounds")?
}

void AttachedMDs(): {} {
	(AttachedMDList())?
}

void AttachedMDList(): {} {
	  AttachedMD()
	| AttachedMD() AttachedMDList()
}

void AttachedMD(): {} {
	MetadataName() MD()
}

void MD(): {} {
	  Metadata()
	| MetadataID()
}

void OptCommaAttachedMDList(): {} {
	(CommaAttachedMDList())?
}

void CommaAttachedMDList(): {} {
	  ","  AttachedMD()
	|  "," AttachedMD() CommaAttachedMDList()
}