// // Based on grammar from https://github.com/llir/grammar

// ### [ Lexical part ] ########################################################

options {
  BUILD_PARSER=false;
 }
 PARSER_BEGIN(llvmir)
 public class llvmir {}
 PARSER_END(llvmir)
 TOKEN_MGR_DECLS: {
 }
 TOKEN: {
   <ascii_letter
	: ["A" - "Z"]
	| ["a" - "z"]
   >
 }
 TOKEN: {
   <letter
	: <ascii_letter>
	| "$"
	| "-"
	| "."
	| "_"
  >
  }
 TOKEN: {
   <escape_letter
    	: <letter>
   	    | "\\"
         >
  }

TOKEN: {
  <decimal_digit: ["0" - "9"]>
}

TOKEN: {<hex_digit
	: <decimal_digit>
	| ["A" - "F"]
	| ["a" - "f"] >
}


SKIP : {
   <COMMENT: ";" ( ~["\n"] )* "\n" >
}

SKIP : {
    <WHITESPACE :  "\\x00" | " " | "\t" | "\r" | "\n">
}

// === [ Identifiers ] =========================================================

TOKEN: {<name
	: <letter> ( <letter> | <decimal_digit> )*
	 >
	 }


TOKEN: {<escape_name
	: <escape_letter> ( <escape_letter> | <decimal_digit> )* >
}

TOKEN: {<quoted_name
	: <quoted_string>
>}


TOKEN: {<id
	: <decimals>
>}

// --- [ Global identifiers ] --------------------------------------------------

TOKEN: {<global_ident
	: <global_name>
	| <global_id>
>}

TOKEN: {<global_name
	: "@" ( <name> | <quoted_name> )
>}

TOKEN: {<global_id
	: "@" <id>
>}

// --- [ Local identifiers ] ---------------------------------------------------

TOKEN: {<local_ident
	: <local_name>
	| <local_id>
>}

TOKEN: {<local_name
	: "%" ( <name> | <quoted_name> )
>}

TOKEN: {<local_id
	: "%" <id> >}


// --- [ Labels ] --------------------------------------------------------------

//   Label             [-a-zA-Z$._0-9]+:

TOKEN: {<label_ident
	: ( <letter> | <decimal_digit> ) ( <letter> | <decimal_digit> )* ":"
	| <quoted_string> ":"
>}


// --- [ Attribute group identifiers ] -----------------------------------------

TOKEN: {<attr_group_id
	: "#" <id>
>}

// --- [ Comdat identifiers ] --------------------------------------------------

TOKEN: {<comdat_name
	: "$" ( <name> | <quoted_name> )
>}


// --- [ Metadata identifiers ] ------------------------------------------------

TOKEN: {<metadata_name
	: "!" <escape_name>
>}


TOKEN: {<metadata_id
	: "!" <id>
>}

// === [ Integer literals ] ====================================================

//   Integer           [-]?[0-9]+

TOKEN: {<int_lit
	: <decimal_lit>
>}

TOKEN: {<decimal_lit
	: ( "-" )? <decimals>
>}

TOKEN: {<decimals
	: <decimal_digit> (<decimal_digit>)*
>}

// === [ Floating-point literals ] =============================================

//   FPConstant        [-+]?[0-9]+[.][0-9]*([eE][-+]?[0-9]+)?

TOKEN: {<float_lit
	: <frac_lit>
	| <sci_lit>
	| <float_hex_lit>
>}

TOKEN: {<frac_lit
	: ( <sign>)? <decimals> "." ( <decimal_digit> )*
>}

TOKEN: {<sign
	: "+"
	| "-"
>}

TOKEN: {<sci_lit
	: <frac_lit> ( "e" | "E" ) ( <sign> )? <decimals>
>}

//   HexFPConstant     0x[0-9A-Fa-f]+     // 16 hex digits
//   HexFP80Constant   0xK[0-9A-Fa-f]+    // 20 hex digits
//   HexFP128Constant  0xL[0-9A-Fa-f]+    // 32 hex digits
//   HexPPC128Constant 0xM[0-9A-Fa-f]+    // 32 hex digits
//   HexHalfConstant   0xH[0-9A-Fa-f]+    // 4 hex digits

TOKEN: {<HexFPConstant :     "0" "x"     (<hex_digit>) * >}
TOKEN: {<HexFP80Constant :   "0" "x" "K" (<hex_digit>) * >}
TOKEN: {<HexFP128Constant :  "0" "x" "L" (<hex_digit>) * >}
TOKEN: {<HexPPC128Constant : "0" "x" "M" (<hex_digit>) * >}
TOKEN: {<HexHalfConstant :   "0" "x" "H" (<hex_digit>) * >}

TOKEN: {<float_hex_lit : <HexFPConstant> | <HexFP80Constant> |
  <HexFP128Constant> | <HexPPC128Constant> | <HexHalfConstant>
>}

// === [ String literals ] =====================================================

TOKEN: {<string_lit
	: <quoted_string> >}


TOKEN: {<quoted_string
	: "\"" ( ~["\""] )* "\""
>}

// === [ Types ] ===============================================================

TOKEN: {<int_type
	: "i" <decimals> >}

TOKEN:{<eq : "=">}

TOKEN:{<lbrace : "{">}

TOKEN:{<rbrace : "}">}

TOKEN:{<exclam : "!">}

TOKEN:{<comma : ",">}

// === [ Modules ] =============================================================

void Module() : {} {
	TopLevelDecls()
}

void TopLevelDecls(): {} {

	(TopLevelDecl())*
}

void TopLevelDecl(): {} {
	SourceFilename() |
	TargetSpec() |
	ModuleAsm () |
	TypeDef() |
	ComdatDef () |
	GlobalDecl () |
	GlobalDef () |
	FuncDecl () |
	FuncDef () |
	AttrGroupDef () |
	NamedMetadataDef () |
	MetadataDef ()
}


// --- [ Source filename ] -----------------------------------------------------

void SourceFilename(): {} {
	"source_filename" "=" <string_lit>
}

// --- [ Target specifiers ] ---------------------------------------------------

void TargetSpec() : {} {
	"target" DataLayout()
	"target" TargetTriple()
}


void DataLayout() : {} {
	"datalayout" "=" <string_lit>
}

void TargetTriple() : {} {
	"triple" "=" <string_lit>
}

// --- [ Module-level inline assembly ] ----------------------------------------

// ref: http://llvm.org/docs/LangRef.html#module-level-inline-assembly
void ModuleAsm() : {} {
	"module" "asm" <string_lit>
}

// --- [ Type definitions ] ----------------------------------------------------

void TypeDef() : {} {
	LocalIdent() "=" "type" Type()
	LocalIdent() "=" "type" "opaque"
}

// --- [ Comdat definitions ] --------------------------------------------------

void ComdatDef() : {} {
	ComdatName() "=" "comdat" SelectionKind()
}

// From spec and src of v4.0.
//
// ref: http://llvm.org/docs/LangRef.html#comdats
void SelectionKind() : {} {
	"any"
	"exactmatch"
	"largest"
	"noduplicates"
	"samesize"
}

// --- [ Global variables ] ----------------------------------------------------

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    GlobalDecl
//       : GlobalIdent "=" ExternLinkage GlobalOptions Immutable FirstClassType OptCommaSection OptCommaComdat OptCommaAlign OptCommaAttachedMDList   << astx.NewGlobalDecl($0, $3, $4, $5, $9) >>
//    ;
void GlobalDecl(): {} {
	  GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Align() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Comdat() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Comdat() "," Align() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() "," Align() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() "," Comdat() OptCommaAttachedMDList()
	| GlobalIdent() "=" ExternLinkage() GlobalOptions() Immutable() FirstClassType() "," Section() "," Comdat() "," Align() OptCommaAttachedMDList()
}

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    GlobalDef
//       : GlobalIdent "=" OptLinkage GlobalOptions Immutable FirstClassType Constant OptCommaSection OptCommaComdat OptCommaAlign OptCommaAttachedMDList   << astx.NewGlobalDef($0, $3, $4, $5, $6, $10) >>
//    ;
void GlobalDef() : {}{
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Align() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Comdat() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Comdat() "," Align() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() "," Align() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() "," Comdat() OptCommaAttachedMDList()
	GlobalIdent() "=" OptLinkage() GlobalOptions() Immutable() FirstClassType() Constant() "," Section() "," Comdat() "," Align()
	                  OptCommaAttachedMDList()
}

void GlobalOptions() : {}{
	OptVisibility() OptDLLStorageClass() OptThreadLocal() OptUnnamedAddr() OptAddrSpace() OptExternallyInitialized()
}

void OptExternallyInitialized(): {} {
	(ExternallyInitialized())?
}

void ExternallyInitialized() : {}{
	"externally_initialized"
}

void Immutable() : {} {
	"constant"
	| "global"
}

// --- [ Functions ] -----------------------------------------------------------

void FuncDecl() : {} {
	"declare" AttachedMDs() OptExternLinkage() FuncHeader()
}

void FuncDef() : {}{
	"define" OptLinkage() FuncHeader() AttachedMDs() FuncBody()
}

void FuncHeader() : {}{
	OptVisibility() OptDLLStorageClass() OptCallConv() ParamAttrs() Type() GlobalIdent()
		"(" (Params())? ")" OptUnnamedAddr() FuncAttrs() OptSection() OptComdat() OptAlign()
		OptGC() OptPrefix() OptPrologue() OptPersonality()
}

void Params() : {}{
	"..."
	| ParamList()
	| ParamList() "," "..."
}

void ParamList() : {}{
	Param()
	| ParamList() "," Param()
}

void Param() : {}{
	FirstClassType() ParamAttrs()
	| FirstClassType() ParamAttrs() LocalIdent()
}

void FuncBody() : {} {
	"{" BasicBlockList() "}"
}

